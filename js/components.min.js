/**  * AI Reality Check - Component Loader  * Loads header and footer components into pages  * Enhanced with improved error handling and path standardization  * Version: 2.0 - April 2025  */ const ComponentConfig = {  paths: {  header: 'components/header.html',  footer: 'components/footer.html'  },  placeholders: {  header: 'header-placeholder',  footer: 'footer-placeholder'  },  fallbacks: {  header: '<header class="error-header"><div class="container"><a href="/" class="logo">AI Reality Check</a></div></header>',  footer: '<footer class="error-footer"><div class="container"><p>&copy; 2025 AI Reality Check</p></div></footer>'  } }; document.addEventListener('DOMContentLoaded', function() {  window.componentLoadingStatus = {  total: 2, // Total number of components to load  loaded: 0, // Counter for successfully loaded components  failed: 0, // Counter for failed component loads  errors: [] // Array to store error messages  };  setTimeout(() => {  loadComponent(  ComponentConfig.placeholders.header,   ComponentConfig.paths.header,  ComponentConfig.fallbacks.header  );  }, 0);  setTimeout(() => {  loadComponent(  ComponentConfig.placeholders.footer,   ComponentConfig.paths.footer,  ComponentConfig.fallbacks.footer  );  }, 10); }); /**  * Loads a component into a placeholder element with error handling  * @param {string} placeholderId - The ID of the placeholder element  * @param {string} componentPath - The path to the component file  * @param {string} fallbackHtml - HTML to use if component loading fails  */ function loadComponent(placeholderId, componentPath, fallbackHtml) {  const placeholder = document.getElementById(placeholderId);  if (!placeholder) {  logComponentError('Placeholder not found', placeholderId, componentPath);  return;  }  placeholder.innerHTML = '<div class="component-loading">Loading component...</div>';  const rootPath = getPathToRoot();  const fullPath = rootPath + componentPath;  const timeoutDuration = 5000; // 5 seconds  const timeout = setTimeout(() => {  handleComponentError(  new Error(`Timeout loading component: ${componentPath}`),  placeholder,  fallbackHtml,  placeholderId,  componentPath  );  }, timeoutDuration);  fetch(fullPath)  .then(response => {  clearTimeout(timeout);  if (!response.ok) {  throw new Error(`Failed to load component: ${response.status} ${response.statusText}`);  }  return response.text();  })  .then(html => {  html = html.replace(/\[ROOT_URL\]/g, rootPath);  placeholder.innerHTML = html;  window.componentLoadingStatus.loaded++;  if (placeholderId === ComponentConfig.placeholders.header) {  if (typeof initMobileNav === 'function') {  try {  initMobileNav();  } catch (error) {  console.warn('Error initializing mobile navigation:', error);  }  }  if (typeof highlightCurrentPage === 'function') {  try {  highlightCurrentPage();  } catch (error) {  console.warn('Error highlighting current page:', error);  }  }  }  })  .catch(error => {  clearTimeout(timeout);  handleComponentError(error, placeholder, fallbackHtml, placeholderId, componentPath);  }); } /**  * Handles component loading errors with fallback content  * @param {Error} error - The error that occurred  * @param {HTMLElement} placeholder - The placeholder element  * @param {string} fallbackHtml - HTML to use as fallback  * @param {string} placeholderId - The ID of the placeholder for logging  * @param {string} componentPath - The component path for logging  */ function handleComponentError(error, placeholder, fallbackHtml, placeholderId, componentPath) {  logComponentError(error.message, placeholderId, componentPath);  window.componentLoadingStatus.failed++;  window.componentLoadingStatus.errors.push({  component: placeholderId,  path: componentPath,  error: error.message  });  if (fallbackHtml && placeholder) {  placeholder.innerHTML = fallbackHtml;  } else if (placeholder) {  placeholder.innerHTML = '<div class="component-error">Component could not be loaded</div>';  }  document.body.classList.add('component-load-error'); } /**  * Logs component errors in a standardized format  * @param {string} message - The error message  * @param {string} placeholderId - The placeholder ID  * @param {string} componentPath - The component path  */ function logComponentError(message, placeholderId, componentPath) {  console.error(  `Component Error [${placeholderId}]: ${message}`,  `\nComponent Path: ${componentPath}`,  `\nPage URL: ${window.location.href}`  ); } /**  * Determines the relative path to the site root directory based on current URL  * Handles various edge cases for consistent path resolution  * @returns {string} The relative path to the root (e.g., '', '../', '../../', etc.)  */ function getPathToRoot() {  let path = window.location.pathname;  if (!path.endsWith('/') && !path.endsWith('.html')) {  path += '/';  }  const segments = path.split('/').filter(segment => segment.length > 0);  if (segments.length === 0) {  return ''; // At root  }  if (segments.length === 1 && segments[0].endsWith('.html')) {  return ''; // HTML file at root level  }  let depth = segments.length;  if (segments.length > 0 && segments[segments.length - 1].endsWith('.html')) {  depth--;  }  let rootPath = '';  for (let i = 0; i < depth; i++) {  rootPath += '../';  }  return rootPath; } 